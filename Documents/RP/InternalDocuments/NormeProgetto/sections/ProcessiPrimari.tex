\documentclass[../NormeProgetto.text]{subfiles}
\begin{document}
\section{Processi primari}
	\subsection{Fornitura}
		\subsubsection{Studio di fattibilità}
			Il documento riguardante lo studio di fattibilità deve essere redatto rapidamente ed in modo accurato dagli \analisti\ sulla base di ciò che è emerso nelle prime riunioni, nelle quali si deve discutere di temi riguardanti i capitolati, come:
			\begin{itemize}
				\item rischi nell'affrontare ogni capitolato\g;
				\item rapporto tra i costi ed i benefici, sia in base al mercato attuale che futuro, sia in base al costo di produzione e alla possibile redditività futura;
				\item il dominio applicativo e tecnologico di ogni capitolato\g.
			\end{itemize}
	\subsection{Sviluppo}
		\subsubsection{Analisi dei requisiti}
			L'\analisideirequisiti\ è il documento dove devono essere catalogati e descritti tutti i requisiti che il prodotto\g\ finale deve soddisfare. Ogni requisito deve emergere da una delle seguenti fonti:
			\begin{itemize}
				\item capitolati\g\ d'appalto;
				\item incontri con il proponente;
				\item incontri con il committente;
				\item valutazioni effettuate durante riunioni interne al gruppo.
			\end{itemize}
			Tale documento deve inoltre riportare il modo in cui ogni requisito deve essere verificato.
				\paragraph{Classificazione dei casi d'uso}
					È compito degli \analisti\ redigere una descrizione, dare una classificazione e fornire un diagramma conforme allo standard UML\g\ per ogni caso d'uso. Ogni caso d'uso dev'essere descritto con le seguenti informazioni, possibilmente in quest'ordine:
					\begin{enumerate}
						\item codice identificativo del caso d'uso, nella forma \begin{center}\textbf{UC[X].[Y]}\end{center} dove:
						\begin{itemize}
							\item \textbf{X} è il codice univoco del padre;
							\item \textbf{Y} è un codice progressivo di livello.
						\end{itemize}
						Il codice progressivo può includere diversi livelli di gerarchia separati da un punto.
						\item titolo, che deve descrivere sinteticamente il caso d'uso;
						\item attori principali;
						\item attori secondari, se questi sono presenti;
						\item precondizioni, ovvero le condizioni che necessariamente devono verificarsi prima del caso d'uso;
						\item postcondizioni, ciò che deve essere verificato successivamente al caso d'uso;
						\item flusso principale degli eventi, dove si descrive il flusso dei casi d'uso figli. Per ogni evento va specificato:
						\begin{itemize}
							\item una descrizione testuale dell'evento;
							\item gli attori coinvolti;
							\item se l'azione è descritta dettagliatamente da un altro caso d'uso.
						\end{itemize}
						\item Scenari alternativi, ovvero scenari in cui si verificano eccezioni o errori. Per ognuno di questi deve essere indicato:
							\begin{itemize}
								\item una descrizione testuale dell'evento;
								\item gli attori coinvolti;
								\item se l'azione è descritta dettagliatamente da un altro caso d'uso.
							\end{itemize}
					\end{enumerate}
				\paragraph{Classificazione dei requisiti}
					È compito degli \analisti\ redigere e classificare i requisiti.  I requisiti devono essere classificati in base al tipo e alla priorità, utilizzando la seguente notazione:
					\begin{center}\textbf{R[X][Y][Z]}\end{center}, dove
						\begin{enumerate}
							\item \textbf{X} indica l'importanza strategica del requisito. Deve assumere solo i seguenti valori:
							\begin{itemize}
								\item \textbf{Obb}: Indica un requisito obbligatorio;
								\item \textbf{Des}: Indica un requisito desiderabile;
								\item \textbf{Opz}: Indica un requisito opzionale.
							\end{itemize}
							\item \textbf{Y} indica la tipologia del requisito. Deve assumere solo i seguenti valori:
							\begin{itemize}
								\item \textbf{F}: Indica un requisito funzionale;
								\item \textbf{Q}: Indica un requisito di qualità;
								\item \textbf{P}: Indica un requisito prestazionale;
								\item \textbf{V}: Indica un requisito vincolo.
							\end{itemize}
							\item \textbf{Z} rappresenta il codice univoco di ogni requisito in forma gerarchica.
						\end{enumerate}
		\subsubsection{Progettazione}
			Lo scopo dell'attività di progettazione è generare una soluzione soddisfacente per tutti gli individui che fanno parte del progetto. Compresi pienamente quali siano i requisiti del problema e approfondendo la progettazione a moduli abbastanza semplici da essere capiti da una sola persona, si otterranno le istruzioni necessarie ai \programmatori\ per sviluppare il prodotto\g\ finito.
		\paragraph{Progettazione architetturale}
			Per poter arrivare alla definizione dell'architettura dei vari prodotti software\g, è necessario passare attraverso una serie di attività, quali:
			\begin{enumerate}
				\item individuare i prodotti che si intendono realizzare;
				\item definire ruoli e responsabilità per ogni prodotto\g\ individuato;
				\item definire le interazioni che i prodotti hanno fra di loro;
				\item assicurarsi che ogni requisito sia soddisfatto da almeno uno dei prodotti individuati;
				\item ci si assicura che ogni prodotto\g\ soddisfi almeno un requisito.
			\end{enumerate}
			A questo punto, è possibile procedere con la progettazione dell'architettura dei prodotti software\g\ che devono essere realizzati. Si devono eseguire e documentare i seguenti task\g\ per ogni prodotto\g\ individuato:
			\begin{enumerate}
				\item suddividere il prodotto\g\ in componenti;
				\item definire il ruolo di ogni componente individuato;
				\item definire le interazioni tra i vari componenti;
				\item definire le interfacce che ogni componente mette a disposizione dell'ambiente esterno;
				\item assicurarsi che ogni requisito sia soddisfatto da almeno uno dei componenti
				\item assicurarsi che ogni componente soddisfi almeno un requisito;
				\item realizzare e documentare i test di integrazione, al fine di verificare il corretto funzionamento di più componenti integrati assieme.
			\end{enumerate}
			Durante la suddivisione del prodotto\g\ in più componenti i \progettisti\ dovranno utilizzare i Design pattern\g\ e, nel farlo, dovranno provvedere a descriverli.
			\subparagraph{Design pattern}
				Per migliorare la comprensibilità delle scelte progettuali e della progettazione stessa i \progettisti\ dovranno indicare i pattern architetturali utilizzati, fornendo per ciascuno d'essi:
				\begin{itemize}
					\item descrizione testuale;
					\item descrizione grafica;
					\item motivazione dell'utilizzo;
					\item descrizione di come viene applicato il pattern al progetto.
				\end{itemize}
			\subparagraph{Diagrammi UML}
				Per documentare prodotti e componenti individuati, sarà necessario ricorrere a dei diagrammi UML\g, necessari per formalizzare gli aspetti descritti in modo testuale. Durante la progettazione architetturale, sarà necessario ricorrere a 
				\begin{description}
					\item[diagrammi dei componenti:]  hanno lo scopo di rappresentare la struttura interna di un prodotto\g\ software\g\ modellato in termini dei suoi componenti principali e delle relazioni fra di essi. Questo tipo di diagramma viene dunque utilizzato per evidenziare i componenti (e le relazioni che essi hanno fra di loro) individuati all'interno di ciascun prodotto\g\ software\g;
					\item[diagrammi delle attività:]  hanno lo scopo di definire le attività da svolgere per realizzare una certa funzionalità. Vengono dunque usati per mostrare come determinate interazioni tra
componenti (o fra prodotti) realizzino una funzionalità che si intende rendere disponibile.
				\end{description}
			\subparagraph{Classificazione dei componenti}
				I componenti vengono identificati univocamente da una descrizione nella forma \begin{center}\textbf{NomeProdotto::NomeComponente}\end{center} dove:
				\begin{itemize}
					\item \textbf{NomeProdotto} è il nome del prodotto\g\ software\g\ che i \progettisti\ hanno individuato;
					\item \textbf{NomeComponente} rappresenta il nome assegnato al componente dai \progettisti.
				\end{itemize}
				Inoltre, ogni componente ha associato un codice univoco nella forma \begin{center}\textbf{[X][Y]}\end{center} dove:
				\begin{itemize}
					\item \textbf{X} è l'iniziale del nome del prodotto\g;
					\item \textbf{Y} è un numero intero incrementale.
				\end{itemize}
			\subparagraph{Test di integrazione}
				Per ottimizzare l'attività di test, i \progettisti\ devono preoccuparsi di definire delle classi di verifica per accertare il funzionamento dei componenti. L'ideale sarebbe fornire degli strumenti automatici ai \verificatori . La progettazione delle classi per la verifica deve essere svolta nel rispetto della mancata sovrapposizione dei ruoli: chi crea una classe non dovrebbe essere lo stesso individuo che crea la classe per testarla.
		\paragraph{Progettazione di dettaglio}
			Una volta definita l'architettura del sistema, si procede alla progettazione di dettaglio, la quale prevede che i seguenti task\g:
			\begin{enumerate}
				\item individuare le classi che implementano ciascuno dei componenti individuati mediante la progettazione architetturale;
				\item definire i ruoli e le responsabilità di ogni classe individuata;
				\item definire nel dettaglio ogni classe;
				\item assicurarsi che ogni requisito sia soddisfatto da almeno di una delle classi definite;
				\item assicurarsi che ogni classe soddisfi almeno un requisito;
				\item realizzare e documentare i test di unità, necessari per verificare il corretto comportamento di ogni classe.
			\end{enumerate}
			
			\subparagraph{Design pattern}
				Per migliorare la comprensibilità delle scelte progettuali e della progettazione stessa i \progettisti\ dovranno indicare i pattern architetturali utilizzati, fornendo per ciascuno d'essi:
				\begin{itemize}
					\item descrizione testuale;
					\item descrizione grafica;
					\item motivazione dell'utilizzo;
					\item descrizione di come viene applicato il pattern al progetto.
				\end{itemize}
			\subparagraph{Diagrammi UML}
				Per documentare prodotti e componenti individuati sarà necessario ricorrere a dei diagrammi UML\g, necessari per formalizzare gli aspetti descritti in modo testuale. Durante la progettazione architetturale, sarà necessario ricorrere a 
				\begin{description}
					\item[diagrammi delle classi:] hanno lo scopo di descrivere i tipi di entità, con le loro caratteristiche ed eventuali relazioni fra questi tipi. Questo diagramma viene utilizzato per evidenziare e descrivere in modo dettagliato le classi e le relazioni che esistono fra di loro;
					\item[diagrammi delle attività:]  hanno lo scopo di definire le attività da svolgere per realizzare una certa funzionalità. Vengono dunque usati per mostrare come determinate interazioni tra componenti (o fra prodotti) realizzino una funzionalità che si intende rendere disponibile;
					\item[diagramma di sequenza] hanno lo scopo di descrivere scenari e vengono usati per descrivere le relazioni che intercorrono, in termini di messaggi, tra attori, oggetti ed entità del sistema rappresentato.
				\end{description}
			
			\subparagraph{Classificazione di una classe}
				Le classi vengono univocamente identificate da una descrizione nella forma \begin{center}
				\textbf{NomeProdotto::NomeComponente::NomeClasse}
				\end{center} dove
				\begin{itemize}
					\item \textbf{NomeProdotto} è il nome del prodotto\g\ software\g\ che i \progettisti\ hanno individuato;
					\item \textbf{NomeComponente} rappresenta il nome assegnato al componente dai \progettisti;
					\item \textbf{NomeClasse} rappresenta il nome che è stato dato dai \progettisti\ alla classe individuata.
				\end{itemize}
				Inoltre, ad ogni classe è associato un codice univoco nella forma \begin{center}
				\textbf{[X][Y]}
				\end{center} dove
				\begin{itemize}
					\item \textbf{X} è l'iniziale del nome del prodotto\g;
					\item \textbf{Y} è un numero intero incrementale.
				\end{itemize}
			\subparagraph{Descrivere una classe}			
				Per descrivere una classe, i \progettisti\ devono preoccuparsi di descrivere:
				\begin{itemize}
					\item nome;
					\item visibilità;
					\item attributi;
					\item metodi;
					\item descrizione generica che indichi lo scopo e la responsabilità della classe.
				\end{itemize}
				Inoltre, devono essere descritte dettagliatamente (anche attraverso diagrammi) le relazioni con altre classi e le interfacce messe a disposizione.
			\subparagraph{Test di unità}
				Per la realizzazione dei test di unità, i \programmatori\ devono rispettare la regola di mancata sovrapposizione dei ruoli: chi realizza il test non deve essere lo stesso individuo che realizza la classe da testare.
		\subsubsection{Codifica}
			\paragraph{Convenzioni}
				Tutti i file contenenti codice o testo dovranno rispettare la codifica UTF-8 senza BOM\g.\\
				I \programmatori, dovendo sviluppare un'applicazione Android\g, dovranno seguire le indicazioni fornite dalla guida Google\g\ Java\g\ Style\footnote{\frmURI{https://google.github.io/styleguide/javaguide.html}}.
			\paragraph{Nomi}
				I nomi di variabili, metodi e classi dovranno essere in notazione CamelCase\g\ e in lingua inglese. I nomi di variabili e metodi dovranno avere la prima lettera minuscola, mentre per le classi sarà maiuscola.
			\paragraph{Ricorsione}
				La ricorsione dovrà essere evitata il più possibile, limitando il suo uso ai soli casi indispensabili, ossia dove sia dimostrato che non è possibile utilizzare un metodo iterativo con complessità computazionale minore. Per ogni metodo ricorsivo, dovrà essere fornita una prova della sua terminazione.
			\paragraph{Documentazione}
				\subparagraph{File}
					I file contenenti codice dovranno avere un'intestazione contenente:
					\begin{lstlisting}
						/**
						 * @author Nome dell'autore
						 * @version Versione corrente del file 
						 * @since Versione del file nel momento
						 *		dell'aggiunta al progetto
						 *
						 * Descrizione del file
						 */
					\end{lstlisting}
				\subparagraph{Classi}
					Poiché in Java\g\ è presente una forte dipendenza tra file e classi (ogni classe in Java\g\ corrisponde ad un file .class), non è necessario aggiungere un ulteriore intestazione. Per le classi interne e quelle anonime dovrà essere aggiunta un'ulteriore intestazione come segue:
					\begin{lstlisting}
						/**
						 * Descrizione della classe
						 */
					\end{lstlisting}
				\subparagraph{Metodi}
					Per ogni metodo, dovrà essere presente un'intestazione contenente:
					\begin{lstlisting}
						/**
						 * Descrizione del metodo
						 * @param NomeParametro1 Descrizione del primo parametro
						 * ...
						 * @param NomeParametroN Descrizione del N-esimo parametro
						 * @return TipoDiRitorno Valore ritornato dal metodo
						 * @throws TipoDiEccezione Motivo di lancio dell'eccezione
						 */
					\end{lstlisting}
					
					Per i costruttori la voce \texttt{@return} deve essere omessa.
				\subparagraph{Casi eccezionali}
					Qualora fosse necessario documentare parti di codice di difficile comprensione è permesso l'utilizzo di un commento nelle righe precedenti, che dovrà essere strutturato come segue:
					\begin{lstlisting}
						/**
						 * Descrizione del blocco di codice
						 */
					\end{lstlisting}
				\paragraph{Versionamento dei file di codice}
					Il numero di versione dei file di codice appare solamente nell'intestazione di ciascuno di essi. Deve seguire il formato:
					\begin{center}\textbf{[X].[Y]}\end{center}, dove
					\begin{itemize}
						\item \textbf{X} è un numero intero, incrementale, corrispondente all'ultima versione stabile del codice;
						\item \textbf{Y} è un numero intero, incrementale, corrispondente al numero di modifiche apportate al codice, partendo dall'ultima versione stabile.
					\end{itemize}
					
				\paragraph{Test}
					\subparagraph{Classificazione dei test}
					È compito dei \programmatori\ creare test di unità e integrazione e degli \analisti\ creare quelli sistema e accettazione al fine di verificare che tutti i requisiti individuati dagli \analisti\ siano soddisfatti. Ogni test deve essere codificato come:
					\begin{center}\textbf{T[X][Y]}\end{center}, dove
						\begin{enumerate}
							\item \textbf{X} rappresenta il tipo di test. Può assumere solo i seguenti valori:
							\begin{itemize}
								\item \textbf{A}: indica un test di accettazione;
								\item \textbf{S}: indica un test di sistema;
								\item \textbf{I}: indica un test di integrazione;
								\item \textbf{U}: indica un test di unità.
							\end{itemize}
							
							\item \textbf{Y} rappresenta il codice univoco di ogni test in forma gerarchica.
						\end{enumerate}
					
		\subsubsection{Procedure}
			\paragraph{Tracciamento componenti-requisiti}
				Per tracciare un requisito su un componente dell'applicazione è sufficiente applicare la seguente procedura su Tracy\g:
				\begin{enumerate}
					\item aprire l'homepage di Tracy\g;
					\item selezionare la voce "Requirements";
					\item individuare il requisito che si desidera tracciare e cliccare su "View";
					\item sotto la voce "Packages" indicare il nome del package\g\ e cliccare su "Add".
				\end{enumerate}
				
				\subparagraph{Inserimento di un componente su Tracy}
					Per inserire un componente all'interno di Tracy\g:
					\begin{enumerate}
						\item aprire l'homepage di Tracy\g;
						\item selezionare la voce "Package";
						\item dal menu "Operations" selezionare la voce "Create package";
						\item riempire almeno i campi obbligatori della form e cliccare su "Create".
					\end{enumerate}
			\paragraph{Tracciamento classi-requisiti}
				Per tracciare un requisito su una classe dell'applicazione è sufficiente applicare la seguente procedura su Tracy\g:
				\begin{enumerate}
					\item aprire l'homepage di Tracy\g;
					\item selezionare la voce "Requirements";
					\item individuare il requisito che si desidera tracciare e cliccare su "View";
					\item sotto la voce "Classes" indicare il nome della classe e cliccare su "Add".
				\end{enumerate}
				\subparagraph{Inserimento di una classe su Tracy}
					Per inserire una classe all'interno di Tracy\g:
					\begin{enumerate}
						\item aprire l'homepage di Tracy\g;
						\item selezionare la voce "Class";
						\item dal menu "Operations" selezionare la voce "Create class";
						\item riempire almeno i campi obbligatori della form e cliccare su "Create".
					\end{enumerate}
		\subsubsection{Strumenti}
			\paragraph{Creazione dei diagrammi UML}
				Lo strumento per la creazione dei diagrammi UML\g\ utilizzato è Astah\g.
			\paragraph{Tracciamento dei requisiti}
				Lo strumento scelto per la il tracciamento dei requisiti è Tracy\g. Questo software\g\ è stato sviluppato dal gruppo di Ingegneria del software\g\ Don't Panic. Il software\g\ è stato scelto per le seguenti caratteristiche:
			\begin{itemize}
				\item open source\g;
				\item tracciamento dei requisiti;
				\item tracciamento use case;
				\item tracciamento delle fonti;
				\item stesura automatica in \LaTeX\g\ dei requisiti.
			\end{itemize}
               Poiché questo software\g\ non risulta essere completamente perfetto, il gruppo ha previsto di riadattarlo sulla base delle esigenze che sono emerse durante la stesura dell'\analisideirequisiti .
 			\paragraph{Tracciamento dei test}
 				Per il tracciamento dei test, verrà utilizzato Tracy\g. Il software\g\ è stato scelto in modo da non dover utilizzare diverse piattaforme per il tracciamento dei requisiti e dei test.
			\paragraph{Scrittura del codice} 			
 				Per lo sviluppo dell'applicazione Android\g, il gruppo ha deciso di utilizzare l'IDE\g\ Android Studio\g\ per i seguenti motivi:
 				\begin{itemize}
 					\item gratis;
 					\item multipiattaforma;
 					\item IDE\g\ di riferimento per lo sviluppo di applicazioni Android\g;
 					\item possibilità di simulare un dispositivo;
 					\item integrabile con GitHub\g;
 					\item basato su IntelliJ Idea\g, strumento già utilizzato dai membri del team\g.
 				\end{itemize}
 				La versione utilizzata dal gruppo è la 1.5.1.
 			\paragraph{Esecuzione dei test}
 				Per la creazione e l'esecuzione dei test di unità e di integrazione, è possibile utilizzare, in combinazione con Android Studio\g, il Framework\g\ JUnit\g.
 			
			
\end{document}

